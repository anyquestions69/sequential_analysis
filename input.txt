 ВОЕННО-КОСМИЧЕСКАЯ АКАДЕМИЯ ИМЕНИ А.Ф.МОЖАЙСКОГО Кафедра Систем сбора и обработки информации (наименование кафедры) (Гриф секретности) Экз. № ____ УТВЕРЖДАЮ Начальник 61 кафедры полковник Д.Бирюков (воинское звание, подпись, инициал имени, фамилия) «____» ___________ 20__ г. Автор: доцент кафедры кандидат технических наук подполковник (должность, ученая степень, ученое и воинское звание, А.Киселев инициал имени, фамилия) Лекция №18 Тема: Разработка программного обеспечения в OC Unix. (наименование темы лекции по тематическому плану изучения дисциплины) по дисциплине Операционные системы (наименование дисциплины) Обсуждено и одобрено на заседании кафедры (предметно-методической комиссии) «____» ____________ 20__ г. протокол № ______ Санкт-Петербург 2018 Содержание занятия и время Введение – 5 мин. Учебные вопросы (основная часть) 1. Системные вызовы и функции стандартных библиотек – 20 мин. (наименование вопроса лекции, время) 2. Создание и компиляция программ( исходные тексты, файловые заголовки) – 20 мин. (наименование вопроса лекции, время) 3. Выполнение программы в ОС Unix. Запуск и завершение С программ – 20 мин. (наименование вопроса лекции, время) 4. Форматы исполняемых файлов в ОС Unix – 20 мин. (наименование вопроса лекции, время) Заключение - 5 мин. Литература: Основная: 1. Робачевский А. Операционная система UNIX. - Спб.: BHV, 2008. – 35-40с. (наименование издания, страницы) Дополнительная: 1. Самонов А.А. Основы профессиональной работы в среде ОС Unix -. Спб.: ВИКА им. А.Ф.Можайского, 2001 (наименование издания, страницы) Материально-техническое обеспечение: 1. Наглядные пособия (по данным учета кафедры): Слайды к вводной лекции. 2. Технические средства обучения: Проектор с ноутбуком. Учебный вопрос №1. Системные вызовы и функции стандартных библиотек. Все версии UNIX предоставляют строго определенный ограниченный набор входов в ядро операционной системы, через которые прикладные задачи имеют возможность воспользоваться базовыми услугами, предоставляемыми UNIX. Эти точки входа получили название системных вызовов (system calls). Системный вызов, таким образом, определяет функцию, выполняемую ядром операционной системы от имени процесса, выполнившего вызов, и является интерфейсом самого низкого уровня взаимодействия прикладных процессов с ядром. Седьмая редакция UNIX включала около 50 системных вызовов, современные версии, например, SVR4, предлагают более 120. В среде программирования UNIX они определяются как функции С, независимо от фактической реализации вызова функции ядра операционной системы. В UNIX используется подход, при котором каждый системный вызов имеет соответствующую функцию (или функции) с тем же именем, хранящуюся в стандартной библиотеке языка С (в дальнейшем эти функции будем для простоты называть системными вызовами). Функции библиотеки выполняют необходимое преобразование аргументов и вызывают требуемую процедуру ядра, используя различные приемы. Помимо системных вызовов программисту предлагается большой набор функций общего назначения. Эти функции не являются точками входа в ядро операционной системы, хотя в процессе выполнения многие из них выполняют системные вызовы. Например, функция printf(3) использует системный вызов для записи данных в файл, в то время как функции strcpy(3) (копирование строки) или atoi(3) (преобразование символа в его числовое значение) вообще не прибегают к услугам операционной системы. Функции, о которых идет речь, хранятся в стандартных библиотеках С и наряду с системными вызовами составляют основу среды программирования в UNIX. Подробное описание этих функций приведено в разделе 3 электронного справочника. Таким образом, часть библиотечных функций является "надстройкой" над системными вызовами, обеспечивающей более удобный способ получения системных услуг. В качестве примера рассмотрим процесс получения текущей даты и времени. Соответствующий системный вызов time возвращает время в секундах, прошедшее с момента Epoch: 1 января 1970 года. Дополнительная интерпретация этого значения, такая как преобразование в вид, удобный для восприятия (дата и время) с учетом временной зоны, осуществляется библиотечными функциями ctime (3), localtime (3) и т. д.. К этим функциям можно отнести функции библиотеки ввода/вывода, функции распределения памяти, часть функций управления процессами и т. д. На рис.1 показана схема взаимодействия приложения с ядром операционной системы при использовании системных вызовов и библиотечных функций. Рис.1 Системные вызовы и библиотечные функции Обработка ошибок Обычно в случае возникновения ошибки системные вызовы возвращают -1 и устанавливают значение переменной errno, указывающее причину возникновения ошибки. Так, например, существует более десятка причин завершения вызова open (2) с ошибкой, и все они могут быть определены с помощью переменной errno. Файл заголовков <errno.h> содержит коды ошибок, значения которых может принимать переменная errno, с краткими комментариями. Библиотечные функции, как правило, не устанавливают значение переменной errno, а код возврата различен для разных функций. Для уточнения возвращаемого значения библиотечной функции необходимо обратиться к электронному справочнику man(1). Поскольку базовым способом получения услуг ядра являются системные вызовы, рассмотрим более подробно обработку ошибок в этом случае. Переменная errno определена следующим образом: external int errno; Стандарт ANSI С определяет две функции, помогающие сообщить причину ошибочной ситуации: strerror (3) и perror(3). Функция strerror (3C) принимает в качестве аргумента errnum номер ошибки и возвращает указатель на строку, содержащую сообщение о причине ошибочной ситуации. Функция perror(3) выводит в стандартный поток сообщений об ошибках информацию об ошибочной ситуации, основываясь на значении переменной errno. Строка s, передаваемая функции, предваряет это сообщение и может служить дополнительной информацией, например содержа название функции или программы, в которой произошла ошибка. Пример использования этих двух функций: Учебный вопрос №2. Создание и компиляция программ. Создание любой программы обычно начинается с базовой идеи: разработки ее блок-схемы, интерфейса пользователя, написания исходного текста. Далее следуют этапы компиляции и отладки. Исходный текст Исходные тексты программы, разработанной для UNIX, по большому счету мало отличаются от текстов приложений, создаваемых для других операционных систем. Можно сказать уверенно, что синтаксис языка определяется не операционной системой. Все, что вам потребуется, это хорошее знание самого языка и особенностей системы UNIX, а именно — ее системных вызовов. Во-первых, не забудьте включить в исходный текст необходимые файлы заголовков. Во-вторых, уточните синтаксис вызова библиотечных и системных функций. В-третьих, используйте их по назначению. В-четвертых, не пренебрегайте комментариями. Заголовки Использование системных функций обычно требует включения в текст программы файлов содержащих определения — число передаваемых аргументов, типы аргументов и возвращаемого значения. Большинство системных файлов заголовков расположены в каталогах /usr/include или /usr/include/sys . Файлы заголовков включаются в программу с помощью директивы #include. При этом, если имя файла заключено в угловые скобки (<>), это означает, что поиск файла будет производиться в общепринятых каталогах хранения файлов заголовков. Пример: системный вызов creat(2) служащий для создания обычного файла, объявлен в файле <fcntl.h> следующим образом: Компиляция Стадии компиляции Рис.2 Стадии компиляции Первой фазой является стадия компиляции, когда файлы с исходными текстами программы, включая файлы заголовков, обрабатываются компилятором сс(1). Параметры компиляции задаются либо с помощью файла makefile (или Makefile), либо явным указанием необходимых опций компилятора в командной строке. В итоге компилятор создает набор промежуточных объектных файлов. На следующей стадии эти файлы с помощью редактора связей ld(1) связываются друг с другом и с различными библиотеками, включая стандартную библиотеку по умолчанию и библиотеки, указанные пользователем в качестве параметров. При этом редактор связей может выполняться в двух режимах: статическом и динамическом, что задается соответствующими опциями. В статическом, наиболее традиционном режиме связываются все объектные модули и статические библиотеки, производится разрешение всех внешних ссылок модулей и создается единый исполняемый файл, содержащий весь необходимый для выполнения код. Во втором случае, редактор связей по возможности подключает разделяемые библиотеки. В результате создается исполняемый файл, к которому в процессе запуска на выполнение будут подключены все разделяемые объекты. В обоих случаях по умолчанию создается исполняемый файл с именем a.out Для достаточно простых задач все фазы автоматически выполняются вызовом команды: $ make prog или $ cc –o prog prog.c которые создают исполняемый файл с именем prog. В этом случае умалчиваемое имя исполняемого файла изменено на prog с помощью опции -о. Учебный вопрос №3. Выполнение программы в ОС Unix. Запуск и завершение С программ. Выполнение программы начинается с создания в памяти ее образа и связанных с процессом структур ядра операционной системы, инициализации и передаче управления инструкциям программы. Завершение программы ведет к освобождению памяти и соответствующих структур ядра. Образ программы в памяти содержит, как минимум, сегменты инструкций и данных, созданные компилятором, а также стек для хранения автоматических переменных при выполнении программы. Запуск С-программы Функция main() является первой функцией, определенной пользователем (т. е. явно описанной в исходном тексте программы), которой будет перe дано управление после создания соответствующего окружения запускаемой на выполнение программы. Традиционно функция main() определяется следующим образом: main(int argc, char *argv[], char *envp[]); Первый аргумент (argc) определяет число параметров, переданных программе, включая ее имя. Указатели на каждый из параметров передаются в массиве argv[],таким образом, через argv[0] адресуется строка, содержащая имя программы, argv[1] указывает на первый параметр и т.д до argv[argc-1]. Массив envp [ ] содержит указатели на переменные окружения, передаваемые программе. Каждая переменная представляет собой строку вида имя_переменной=значение_переменной. Стандарт ANSI С определяет только два первых аргумента функции main — argc и argv. Стандарт POSIX.1 определяет также аргумент envp, хотя рекомендует передачу окружения программы производить через глобальную переменную environ, как это показано на рис. 3: extern char *evrion; Рекомендуется следовать последнему формату передачи для лучшей переносимости программ на другие платформы UNIX. Рис. 3 - Передача переменных окружения Приведем пример программы, соответствующую стандарту которая выводит значения всех аргументов, переданных функции число переданных параметров, сами параметры и значения первых десяти переменных окружения. В результате компиляции будет создан исполняемый файл программы (по умолчанию a.out). Запустив его, мы увидим следующую информацию: Завершение C-программ. Существует несколько способов завершения программы. Основными являются возврат из функции main() и вызов функций exit(), оба приводят к завершению выполнения задачи. Системный вызов exit(2) выглядит следующим образом: Аргумент status, передаваемый функции возвращается родительскому процессу и представляет собой код возврата программы. Наличие кода возврата позволяет программам взаимодействовать друг с другом. Значение кода неудачи может иметь дополнительную трактовку, определяемую самой программой. Например, программа grep(l), выполняющая поиск заданных подстрок в файлах, определяет следующие коды возврата: 0 - совпадение было найдено 1 - совпадений найдено не было 2 - синтаксическая ошибка или недоступны файлы поиска Помимо передачи кода возврата, функция exit(2) производит ряд действий, в частности выводит буферизованные данные и закрывает потоки ввода/вывода. Альтернативой ей является функция _exit(2), которая не производит вызовов библиотеки ввода/вывода, а сразу вызывает системную функцию завершения ядра. Задача может зарегистрировать обработчики выхода (exit handler), — функции, которые вызываются после вызова exit(2), но до окончательного завершения процесса. Эти обработчики, вызываемые по принципу LIFO (последний зарегистрированный обработчик будет вызван первым), запускаются только при "добровольном" завершении процесса. Например, при получении процессом сигнала обработчики выхода вызываться не будут. Для обработки таких ситуаций следует использовать специальные функции — обработчики сигналов. Обработчики выхода регистрируются с помощью функции atexit(3): На рис. 4 проиллюстрированы возможные варианты запуска и завершения программы, написанной на языке С. Рис.4 Учебный вопрос №4. Форматы исполняемых файлов в ОС Unix. Виртуальная память процесса состоит из нескольких сегментов или областей памяти. Размер, содержимое и расположение сегментов в памяти определяется как самой программой, например, использованием библиотек, размером кода и данных, так и форматом исполняемого файла этой программы. В большинстве современных операционных систем UNIX используются два стандартных формата исполняемых файлов — COFF (Common Object File Format) и ELF (Executable and Linking Format). На рис. 2.3 приведена базовая структура памяти для процессов, загруженных из исполняемых файлов форматов COFF и ELF, соответственно. Хотя расположение сегментов различается для этих двух форматов, основные компоненты одни и те же. Оба процесса имеют сегменты кода (text), данных (data), стека (stack). Как видно из рисунка, размер сегментов данных и стека может изменяться, а направление этого изменения определяется форматом исполняемого файла. Размер стека автоматически изменяется операционной системой, в то время как управление размером сегмента данных производится самим приложением. Виртуальная память процесса Рис.5 Формат ELF Формат ELF имеет файлы нескольких типов, которые до сих пор мы называли по-разному, например, исполняемый файл или объектный файл. Тем не менее стандарт ELF различает следующие типы: Перемещаемый файл (relocatable file) хранящий инструкции и данные, которые могут быть связаны с другими объектными файлами. Результатом такого связывания может быть исполняемый файл или разделяемый объектный файл. Разделяемый объектный файл (shared object file) также содержит инструкции и данные, но может быть использован двумя способами. В первом случае, он может быть связан с другими перемещаемыми файлами и разделяемыми объектными файлами, в результате будет создан новый объектный файл. Во втором случае, при запуске программы на выполнение операционная система может динамически связать его с исполняемым файлом программы, в результате чего будет создан исполняемый образ программы. В последнем случае речь идет о разделяемых библиотеках. Исполняемый файл хранит полное описание, позволяющее системе создать образ процесса. Он содержит инструкции, данные, описание необходимых разделяемых объектных файлов, а также необходимую символьную и отладочную информацию. Формат COFF Исполняемый файл содержит два основных заголовка — заголовок COFF и стандартный заголовок системы UNIX — a.out. Далее следуют заголовки разделов и сами разделы файла, в которых хранятся инструкции и данные программы. Наконец, в файле также хранится символьная информация, необходимая для отладки. Символьная информация состоит из таблицы символов (symbol table) и таблицы строк (string table). В первой таблице хранятся символы, их адреса и типы. Например, мы можем определить, что символ locptr является указателем и его виртуальный адрес равен Ox7fehO. Далее, используя этот адрес, мы можем выяснить значение символа для выполняющегося процесса. Записи таблицы символов имеют фиксированный размер. Если длина символа превышает восемь знаков, его имя хранится во второй таблице — таблице строк. Обычно обе эти таблицы присутствуют в объектных и исполняемых файлах, если они явно не удалены, например, командой strip(l). Как и в случае ELF файла, заголовок содержит общую информацию, позволяющую определить местоположение остальных компонентов. Методические рекомендации преподавателю по проведению лекции: Лекции составляют основу теоретического обучения и дают систематизированные основы научных знаний по дисциплине «Операционные системы», раскрывают состояние и перспективы развития соответствующей предметной области, концентрируют внимание обучающихся на наиболее сложных и узловых вопросах, стимулируют их активную познавательную деятельность и способствуют формированию творческого мышления. Ведущим методом в лекции выступает устное изложение учебного материала, сопровождающееся демонстрацией мультимедийных слайдов, видеофильмов, схем, плакатов, показом программных моделей, макетов программного обеспечения подсистем изучаемых операционных систем. При проведении лекции рекомендуется использовать следующие методические приемы: 1. Предварительная целевая ориентация каждого изучаемого вопроса с приведением примеров из практики. 2. Систематизация, предполагающая выявление, анализ, классификацию и учет всех факторов, влияющих на результат. 3. Последовательная многоуровневая декомпозиция материала. 4. Многомодельное рассмотрение изучаемых вопросов. 5. Абстрагирование, предполагающее отвлечение от несущественных деталей. 6. Осмысливание и закрепление изучаемого материала. Методические рекомендации (задания) для слушателей и курсантов: В ходе лекционных занятий вести конспектирование учебного материала. Обращать внимание на категории, формулировки, раскрывающие содержание тех или иных явлений и процессов, научные выводы и практические рекомендации, положительный опыт в ораторском искусстве. Желательно оставить в рабочих конспектах поля, на которых делать пометки из рекомендованной литературы, дополняющие материал прослушанной лекции, а также подчеркивающие особую важность тех или иных теоретических положений. Задавать преподавателю уточняющие вопросы с целью уяснения теоретических положений, разрешения спорных ситуаций. подполковник А.Киселев (воинское звание, подпись, инициал имени, фамилия автора) «_____» ___________ 20_ г. 