1. ОБЩИЕ СВЕДЕНИЯ О ЯЗЫКЕ, ПЕРЕВОДЕ И СТРУКТУРЕ ТРАНСЛЯТОРА Массовое производство ЭВМ, быстро возрастающая роль малых и осо-бенно персональных ЭВМ привели к необходимости найти новые метода и средства программирования прикладных и системных задач. В этом вопросе достигнут определений прогресс, однако ни новые инструментальные систе-мы, ни новейшие технологии и новейшие стили программирования (логиче-ский, концептуальный и другие), не нарушили основополагающего значения алгоритмических языков в разработке как базового программного обеспече-ния ЭВМ, так и различных программных средств для непрограммистов. В последнее время все большую популярность завоевывают алгоритми-ческие языки, появившиеся в 80-х годах, такие как Паскаль, Си, Ада и др. Успех в распространении этих языков связан не только с включением в языки новых средств описания и обработки сложных структур данных, но и с разра-боткой надежных и эффективных трансляторов с этих языков. Последнее обя-зано в первую очередь практическим и научным результатам, полученными теории синтаксически управляемого перевода и методах трансляции. 1.1. Схема работы транслятора Каждая вычислительная машина имеет свой собственный язык про-граммирования – язык команд или машинный язык – и может исполнять про-граммы, записанные только на этом языке. С помощью машинного языка, в принципе, можно описать любой алгоритм, но затраты на программирование будут чрезвычайно велики. Это обусловлено тем, что машинный язык позво-ляет описывать и обрабатывать лишь примитивные структуры данных – бит, байт, слово. Программирование в машинных кодах требует чрезмерной дета-лизации программы и доступно лишь программистам, хорошо знающим устройство и функционирование ЭВМ. Преодолеть эту трудность и позволили языки высокого уровня (Фортран, ПЛ/1, Паскаль, Си, Ада, и др.) с развитыми структурами данных и средствами их обработки, не зависящими от языка кон-кретной ЭВМ. Алгоритмические языки высокого уровня обладают достаточно высокой изобразительной силой, они дают возможность программисту достаточно просто и удобно описывать алгоритмы решения многих прикладных задач. Такое описание называют исходной программой, а язык высокого уровня – входным языком. Языковым процессором называют программу на машинном языке, поз-воляющую вычислительной машине понимать и выполнять программы на входном языке. Различают два основных типа языковых процессоров: интер-претаторы и трансляторы [2]. Интерпретатор – это программа, которая в качестве входа допускает программу на входном языке и по мере распознавания конструкций входного языка реализует их, выдавая на выходе результаты вычислений, предписан-ные исходной программой. Транслятор – это программа, которая допускает на входе исходную программу и порождает на своем выходе программу, функционально-эквивалент-ную исходной, называемую объектной. Объектная программа за-писывается на объектном языке. В частном случае, объектным языком может служить машинный язык, и в этом случае полученную на выходе транслятора программу можно сразу же выполнить на ЭВМ (проинтерпретировать). При этом ЭВМ является интерпретатором объектной программы в машинных ко-дах. В общем случае объектный язык необязательно должен быть машинным или близким к нему (автокодом). В качестве объектного языка может служить некоторый промежуточный язык – язык, лежащий между входным и машин-ным языками. Если в качестве объектного языка используется промежуточный язык, то возможны два варианта построения транслятора. Первый вариант – для промежуточного языка имеется (или разрабаты-вается) другой транслятор – с промежуточного языка на машинный, и он ис-пользуется в качестве последнего блока проектируемого транслятора. Второй вариант построения транслятора с использованием промежу-точного языка – построить интерпретатор команд промежуточного языка и использовать его в качестве последнего блока транслятора. Преимущество интерпретаторов проявляется в отладочных и диалоговых трансляторах, обеспечивающих работу пользователя в диалоговом режиме, вплоть до внесе-ний изменений в программу без ее повторной полной перетрансляций. Интерпретаторы используются также и при эмуляции программ – ис-полнении на технологической машине программ, составленных для другой (объектной) машины. Данный вариант, в частности, используется при отладке на универсальной ЭВМ программ, которые будут выполняться на специали-зированной ЭВМ. Транслятор, использующий в качестве входного языка язык, близкий к машинному (автокод или ассемблер), традиционно называют ассемблером. Транслятор для языка высокого уровня называют компилятором. В построении компиляторов за последние годы достигнуты значитель-ные успехи. Первые компиляторы использовали так называемые прямые ме-тоды трансляции – это преимущественно эвристические методы, в которых на основе общей идеи для каждой конструкции языка разрабатывался свой алго-ритм перевода в машинный эквивалент [2]. Эти методы были медленные и не носили структурного характера. В основе методики проектирования совре-менных компиляторов лежит композиционный синтаксически управляемый метод обработки языков. Композиционный в том смысле, что процесс перево-да исходной программы в объектную реализуется композицией функциональ-но независимых отображений с явно выделенными входными и выходными структурами данных. Отображения эти строятся из рассмотрения исходной программы, как композиции основных аспектов (уровней) описания входного языка: лексики, синтаксиса, семантики и прагматики, и выявления этих аспек-тов из исходной программы в ходе ее компиляции. Рассмотрим эти аспекты с целью получения упрощенной модели компилятора. Основой любого естественного или искусственного языка является ал-фавит – набор допустимых в языке элементарных знаков (букв, цифр и слу-жебных знаков). Знаки могут объединяться в слова – элементарные конструк-ции языка, рассматриваемые в тексте (программе) как неделимые символы, имеющие определенный смысл. Словом может быть и одиночный символ. Например, в языке ПЛ/1 словами являются идентификаторы, ключевые слова, константы и разделители, в частности знаки арифметических и логических операций, скобки, запятые и другие символы. Словарный состав языка вместе с описанием способов их представления составляют лексику языка. Слова в языке объединяются в более сложные конструкции предложе-ния. В языках программирования простейшим предложением является опера-тор. Предложения строятся из слов и более простых предложений по прави-лам синтаксиса. Синтаксис языка представляет собой описание правильных предложений. Описание смысла предложений, т.е. значений слов и их внут-ренних связей, составляет семантику языка. В дополнение отметим, что кон-кретная программа несет в себе некоторое воздействие на транслятор – праг-матизм. В совокупности синтаксис, семантика и прагматизм языка образуют семиотику языка. Перевод программы с одного языка на другой в общем случае состоит в изменении алфавита, лексики и синтаксиса языка программы с сохранением ее семантики. Процесс трансляции исходной программы в объектную обычно разбивается на несколько независимых подпроцессов (фаз трансляции), кото-рые реализуются соответствующими блоками транслятора. Удобно считать основными фазами трансляции лексический анализ, синтаксический анализ, семантический анализ и синтез объектной программы. Тем не менее, во многих реальных компиляторах эти фазы разбиваются на несколько подфаз, могут также быть и другие фазы (например, оптимизация объектного кода) [5]. На рис. 1.1. показана упрощенная функциональная модель транслятора. В соответствии с этой моделью входная программа прежде всего под-вергается лексической обработке. Цель лексического анализа – перевод ис-ходной программы на внутренний язык компилятора, в котором ключевые слова, идентификаторы, метки и константы приведены к одному формату и заменены условными кодами: числовыми или символьными, которые называ-ют дескрипторами. Каждый дескриптор состоит из двух частей: класса (типа) лексемы и указателя на адрес в памяти, где хранится информация о конкрет-ной лексеме. Обычно эта информация организуется в виде таблиц. Одновре-менно с переводом исходной программы на внутренний язык на этапе лекси-ческого анализа проводится лексический контроль – выявление в программе недопустимых слов. Рис.1.1. Упрощенная функциональная модель транслятора Синтаксический анализатор воспринимает выход лексического анали-затора и переводит последовательность образов лексем в форму промежуточ-ной программы. Промежуточная программа является, по существу, представ-лением синтаксического дерева программы. Последнее отражает структуру исходной программы, т.е. порядок и связи между ее операторами. В ходе по-строения синтаксического дерева выполняется синтаксический контроль - вы-явление синтаксических ошибок в программе. Фактическим выходом синтаксического анализатора может быть по-следовательность команд, необходимых для того, чтобы строить промежу-точную программу, обращаться к таблицам справочника, выдавать, когда это требуется, диагностические сообщения [5]. Синтез объектной программы начинается, как правило, с распределения и выделения памяти для основных программных объектов. Затем производит-ся исследование каждого предложения исходной программы, и генерируются семантически эквивалентные предложения объектного языка. В качестве входной информации здесь используется синтаксическое дерево программы и выходные таблицы лексического анализатора – таблица идентификаторов, таблица констант и другие. Анализ дерева позволяет выявить последователь-ность генерируемых команд объектной программы, а по таблице идентифика-торов определяются типы команд, которые допустимы для значений операн-дов в генерируемых командах (например, какие требуется породить команды: с фиксированной или плавающей точной и т.д.). Непосредственно генерации объектной программы часто предшествует семантический анализ, который включает различные виды семантической об-работки. Один из видов – проверка семантических соглашений в программе. Примеры таких соглашений: единственность описания каждого идентифика-тора в программе, определение переменной производится до ее использования и т.д. Семантический анализ выполняться и на более поздних фазах трансля-ции, например, на фазе оптимизации программы, которая тоже может вклю-чаться в транслятор. Цель оптимизации – сокращение временных ресурсов или ресурсов оперативной памяти, требуемых для выполнения объектной про-граммы. Таковы основные аспекты процесса трансляции с языков высокого уровня. Подробнее организация различных фаз трансляции и связанные с ни-ми практические способы их математического описания рассматриваются ниже. 1.2. Описание входного языка транслятора Первое, что отличает один язык программирования от другого – это их синтаксис. Основное назначение синтаксиса – предоставить систему обозна-чений для обмена информацией между программистом и транслятором. Одна-ко при разработке деталей синтаксиса чаще исходят из второстепенных кри-териев, назначение которых: сделать программу удобной для чтения, написа-ния и трансляции, а также сделать ее однозначной. Если удобство чтения и записи программ необходимы для пользователя языка программирования, то простота трансляции и отсутствие разночтений в языке имеют отношение к нуждам транслятора. Эти цели, в общем случае, противоречивы, и нахожде-ние приемлемого компромисса при их решении является одной из централь-ных задач при разработке языка программирования. Разработка нового языка программирования начинается с определения его синтаксиса. Для описания синтаксиса языка программирования, в свою очередь нужен также некоторый класс. Язык, предназначенный для описания другого языка, называют метаязыком. Язык, используемый для описания син-таксиса языка, называют метасинтаксическим языком. В метасинтаксических языках используется специальная совокупность условных знаков, которая об-разует нотацию этого языка. Исторически первым метасинтаксическим языком, который использо-вался на практике для описания синтаксиса языков программирования (в частности Алгола-60), являются нормальные формы Бэкуса, сокращенно обо-значают БНФ – бэкусова нормальная форма или бэкусо-науровская форма. Основное назначение форм Бэкуса состоит в представлении в сжатом и ком-пактном виде строго формальных и однозначных правил написания основных конструкций описываемого языка программирования. Формальное определение синтаксиса языка программирования обычно называется грамматикой. В форме Бэкуса описываются два класса объектов: это, во-первых, ос-новные символы языка программирования и, во-вторых, имена конструкций описываемого языка, или так называемые, металингвистические переменные. Каждая металингвистическая формула (форма) описывает правила по-строения конструкций языка и состоит из двух частей. В левой находится ме-талингвистическая переменная, обозначающая соответствующую конструк-цию. Далее следует металингвистическая связка ::=, означающая «определя-ется как» или «есть». В правой части формулы указывается один или несколь-ко вариантов построения конструкции, определяемой в левой части. Для по-строения определяемой формулой конструкции нужно выбрать некоторый ва-риант ее построения из правой части формулы и подставить вместо каждой металингвистической переменной некоторые цепочки основных символов. Ва-рианты правой части формулы разделяются металингвистичской связкой |, имеющей смысл «или». Сами металингвистические переменные обозначаются словами, пояс-няющими смысл описываемой конструкции, и заключаются в угловые скобки < >. В качестве примера БНФ приведем определение десятичного целого числа: 1. < десятичное целое число > ::= < число без знака > | + < число без знака > | – < число без знака > 2. < число без знака > ::= < цифра > | < число без знака > < цифра > 3. <цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9. Например, число +294 выводится по формулам следующим образом: < десятичное целое число >, + < число без знака >, + < число без знака > < цифра >, + < число без знака > 4, + < число без знака > < цифра > 4, + < целое без знака > 94, + < цифра > 94, + 294. Особенностью многих металингвистических формул является наличие в них рекурсий, т.е. использование для описания конструкций самих описывае-мых конструкций. Рекурсия может быть явной и неявной. Явная рекурсия имеет место, например, в правиле числа. Неявная рекурсия присутствует в случае, когда при построении конструкции на некотором шаге используется мета-лингвистическая переменная обозначающая саму эту конструкцию. Наличие рекурсий затрудняет чтение и понимание металингвистиче-ских формул, однако это едва ли не единственный способ, позволяющий с по-мощью конечного числа правил описать язык, который может содержать бес-конечное число цепочек основных символов. Языки же программирования бесконечны, т.е. на них можно записать бесконечное число правильных про-грамм, и при описании их синтаксиса с помощью БНФ всегда будут присут-ствовать явные или неявные рекурсии. На практике для описания синтаксиса языков программирования при-меняются и другие металингвистические языки. Одна из целей их использова-ния – устранить некоторую неестественность представления в БНФ общих синтаксических конструкций для необязательных, альтернативных и повто-ряющихся элементов правил. Так для описания синтаксиса таких языков, как КОБОЛ и ПЛ/1, используется следующая нотация, являющаяся расширением БНФ: 1. Необязательный элемент внутри правила заключается в квадратные скобки [. . .]. 2. Альтернативные элементы обозначаются вертикальным списком ва-риантов, заключенным в фигурные скобки {. . .}. 3. Необязательные альтернативные варианты обозначаются вертикаль-ным списком вариантов, заключенным в квадратные скобки [. . .]. 4. Повторяющийся элемент обозначается списком из одного элемента (заключенного, если это необходим, в фигурные или квадратные скобки) со следующим за ним обычным многоточием . . . . 5. Обязательные ключевые слова подчеркиваются, а не обязательные шумовые слова – нет. Приводимое ранее описание БНФ десятичного числа в данной нотации будет иметь вид: < десятичное целое > ::= [ ] < цифра > … < цифра > ::= { 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 } Такое описание более компактно и естественно. Однако оба описания эквивалентны, т.е. любое правило, записанное на этом языке, может быть од-нозначно в виде одной или нескольких форм Бэкуса и наоборот. Формы Бэкуса представляют более формальное описание языка и они, по существу, натолкнули исследователей на внедрение математических средств для системного описания и исследования языков программирования, использование математического аппарата как основы для синтаксического анализа в трансляторах, что позднее получило развитие в разнообразных ме-тодах синтаксического анализа, основанных на формальных синтаксических определениях. Необходимо отметить, что БНФ не позволяет описывать контекстные зависимости в языке программирования. Например, такое ограничение ПЛ/1 программ, как "идентификатор не может быть описан дважды в одном и том же блоке" нельзя описать средствами БНФ. Ограничения такого рода ближе уже к другой характеристике языка – семантике. Поэтому здесь используются другие средства, в общем случае называемые метасемантическими языками. Однако, как правило, ядром этим языков является та же БНФ. 1.3. Формальное определение языков программирования Систематическое использование математических методов для описания языков программирования восходит к 1960 году. Тогда было обнаружено, что формальные формы Бэкуса, которые использовались для описания синтаксиса языка АЛГОЛ-60, имеют строгое формальное обоснование с помощью средств математической лингвистики. С этого времени и началась история развития и применения формального математического аппарата – теории формальных языков и грамматик – для проектирования и конструирования трансляторов. 1.3.1. Формальные языки и грамматики Первоначально наука о языках – лингвистика – сводилась к изучению конкретных естественных языков, их классификации, выяснению сходств и различий между ними. Возникновение и развитие метаматематики, изучающей язык математики, проведение работ по изучению средств коммуникации жи-вотных и другие исследования привели в 30-х годах к существенно более ши-рокому представлению о языке, при котором под языком понимается всякое средство общения, состоящее из [1]: 1. знаковой системы, т.е. множества допустимых последовательностей знаков; 2. множества смыслов этой системы; 3. соответствия между последовательностями знаков и смыслами, дела-ющего "осмысленными" допустимые последовательности знаков. Знаками могут быть буквы алфавита, математические обозначения, зву-ки и т.д. Математическая лингвистика рассматривает только такие знаковые системы, в которых знаками являются символы некоторого алфавита, а после-довательностями знаков – тексты, т.е. языки рассматриваются как произволь-ные последовательности осмысленных текстов. При этом правила, определя-ющие, множество текстов образуют синтаксис языка, а описание множества смыслов и соответствия между смыслами и текстами – семантику языка. Се-мантика языка зависит от характера объектов, описываемых языком, и сред-ства ее изучения различны для различных типов языков. Синтаксис же языка, как оказалось, в меньшей степени зависит от назначения языка и может изу-чаться методами, не зависящими от содержания и назначения языка. Матема-тический аппарат для изучения синтаксиса языков получил назвавние теория формальных грамматик. С точки зрения синтаксиса язык здесь понимается уже не как средство общения, а как множество формальных объектов – после-довательностей символов алфавита. Термин "формальный" подчеркивает, что объекты и операции над ними рассматриваются чисто формально, без каких либо содержательных интерпретаций объектов. Воспроизведем основные термины и определения этой теории. Буква (или символ) – это простой неделимый знак; множество букв об-разует алфавит. Алфавиты являются множествами, и поэтому к ним можно применять теоретико-множественные обозначения. В частности, если А и В такие алфавиты, что AB, то будем говорить, что А является подалфавитом В. Цепочка – упорядоченная последовательность букв алфавита. Пусть А – алфавит, тогда цепочки одинаковой длины являются элементами множества: An = A A ... A и записываются в виде: a1a2…an, а не a1, a2, … , an как это при-нято для обозначения элементов декартового произведения множеств. Буквы также являются цепочками для случая n = 1. Цепочка может и не иметь букв, тогда это пустая цепочка, будем обозначать эту цепочку символом . При этом не является буквой, т.е. А. Цепочки будем называть также словами. Множество всех возможных цепочек (слов) над алфавитом А называют замыканием А и обозначают А*, так что , здесь . Множество А* называют итерацией алфавита А. Множество непустых цепочек (слов) над алфавитом А (усеченная итерация алфавита А) определятся как: . Каждая цепочка А* имеет конечную длину, которая обозначается через || и равна числу букв в , при этом || = 0. Цепочки могут образовывать последовательности цепочек. Для этих це-лей используется бинарная операция над цепочками, которая называется кон-катенацией. Операция конкатенации обозначается знаком , определяется на множестве А* следующим образом: если ,   А*, то  = , т.е. результа-том выполнения операции является цепочка  и сразу же за ней записанная цепочка . Операция  ассоциативна, но не коммуникативна. При этом  =  =  для любых цепочек  и || = || + ||. Если цепочки состоят из повторяющихся букв, то применяются сокра-щенные обозначения, чтобы показать, что цепочку нужно рассматривать как произведение букв алфавита. Поэтому, например, с помощью буквы хА мож-но образовать цепочки  = x0, xx = x2, xxn-1 = xn и т.д. Это же используется для обозначения повторяющихся цепочек: например цепочку хухух можно запи-сать как x(yx)2 или (xy)2x при этом символы (, )  А. При преобразовании одних цепочек в другие используется понятие под-цепочки. Пусть ,   А, А – алфавит. Цепочка  называется подцепочкой , если  = ; ,   А*. Альтернативным набором терминов для буквы, алфавита или цепочки (слова) является набор: слово, словарь и предложение соответственно. Сово-купность цепочек (или предложений) называется языком. Формально язык L над алфавитом А – это множество цепочек А*, поэтому LA*. Следовательно операции над цепочками индуцируют операции на языках. Отсюда получаем: Таким образом, используя приведенную выше терминологию, язык про-граммирования для заданного алфавита А является таким подмножеством множества А*, которое включает в себя только те предложения, которые бла-годаря внешней информации об их семантике считаются осмысленными, т.е. удовлетворяют синтаксису языка программирования. Приведенное определение формального языка как любого подмноже-ства А* является чересчур общим: оно не позволяет выделять среди множе-ства языков отдельные их классы, которые используются на практике. Выде-лять такие классы можно, используя соотношения Туэ (названными так в честь норвежского математика, впервые их использовавшего). Соотношениями Туэ называют правила, согласно которым любой це-почке  = i из А* ставится в соответствие цепочка  = i из того же множества А*(i = 1, 2, … , n) и наоборот. Соотношения Туэ приводят к так называемым ассоциативным исчислениям [7]. Однако и соотношения Туэ слишком общи, чтобы быть основой исследования таких свойств, как синтак-сис языков программирования. Наложение ограничений на правила туэтов-ских систем – введение односторонних правил, в этом случае их называют по-лусоотношениями или продукциями (обозначают их i  i), привело к созда-нию формального математического аппарата - формальным грамматикам, ко-торые являются, по-существу, полусистемами Туэ, и которые оказались наиболее приемлемым механизмом описания языков программирования. Теория формальных грамматик занимается описанием, распознаванием и переработкой языков. Она позволяет ответить на ряд прикладных вопросов. Например, могут ли языки из некоторого класса Z распознаваться быстро и просто; принадлежит ли данный язык классу Z; существуют ли алгоритмы, которые давали бы ответ на вопросы типа: "Принадлежит или нет к языку L цепочка ?" и т.д. В общем случае существуют два основных способа описания отдель-ных классов языков: 1. с помощью порождающей процедуры; 2. с помощью распознающей процедуры. Первая из них задается с помощью конечного множества правил, назы-ваемых грамматикой и порождающих в точности те цепочки, которые при-надлежат языку L. Вторая – с помощью некоторого абстрактного распознаю-щего устройства (автомата). При построении трансляторов используются оба эти способа: грамматика как средство описания синтаксиса языка програм-мирования, а автомат как модель алгоритма распознавания предложений язы-ка, который кладется в основу построения транслятора. При этом методически (и технологически) сначала конструируется грамматика, а затем уже по ней, как по источнику, строится алгоритм распознавания. Перейдем теперь к формальному изложению рассмотренных выше по-нятий. 1.3.2. Порождающая грамматика Определение 1.3.2.1. Формальной порождающей грамматикой называ-ется четверка G = <N, T, P, S>, где Т – конечное непустое множество символов, называемое терминальным (основным) словарем грамматики G; N – конечное непустое множество символов, называемое нетерминаль-ным (вспомогательным) словарем грамматики G, T N = , V = T N – объеди-ненный словарь грамматики G; элементы множества N называют нетерми-нальными символами (или нетерминалами); S – начальный символ (аксиома) грамматики G; SN и обозначает глав-ный нетерминал (цель) грамматики G; Р – конечное множество правил грамматики, т.е. цепочек вида  и называемых также правилами подстановки или продукциями, при этом ,  – цепочки в словаре V=T U N и   (T U N)*,   (N U T)*. Конечное двуместное отношение  интерпретируется как "заменить  на " или "подставить  вме-сто ". Множество правил подстановки Р называют также схемой грамматики. Цепочка, стоящая в левой части правила грамматики, обязательно содержит хотя бы один нетерминальный символ. В правой же части правила в общем случае может стоять произвольная цепочка из терминальных и нетерминаль-ных символов, включая и пустую цепочку . В дальнейшем элементы из нетерминального словаря N будем обозна-чать прописными латинскими буквами А, В, С, … , элементы из Т (терминаль-ные символы) – строчными латинскими буквами a, b, с, … , произвольные це-почки - греческими буквами , , , … . Будем говорить, что цепочка ' выводима из цепочки  в грамматике G ('), если  = 12, ' = 12 и в множестве правил подстановки P найдется правило . Будем говорить, что цепочка ' выводима из цепочки  в грамматике G ('), если найдется последовательность цепочек  = 0, 1, … , n = ' та-кая, что цепочка i+1 непосредственно выводима в грамматике G из цепочки i, т.е. (ii+1) при i = 0, 1, … n–1, либо ' = . Всюду ' - произвольная цепочка, т.е. i  (N T)*. Отношение  называется транзитивным замыканием, а по-следовательность цепочек, 0, 1, … , n - выводом цепочки n из цепочки 0 в грамматике G. Определение 1.3.2.2. Множество всех цепочек терминальных символов, выводимых из аксиомы грамматики, называется языком, порождаемым этой грамматикой, т.е. L(G) = {x | Sx, xT*}. Пример 1.3.2.1. [1]. Рассмотрим грамматику G = <N, T, P, S> у которой: N = {I}, T = {a, b, c, V, &, , (, )}, S = {I}, Р = { I  ( I V I ) I  ( I & I ) I  I I  a I  b I  c } Эта грамматика описывает язык булевых формул с переменными a, b, c и логическими функциями V, &, . Примером вывода в этой грамматике являет-ся вывод: . Пример 1.3.2.2. Язык anbnan порождается следующей грамматикой G = <N, T, P, S>, у которой: N = {I, A, B, C, D}, T = {a, b, c}, S = {I}, P = { I  ABA В  ABCA B  b bC  bb AC  DC DC  DA DA  CA A  a } Примером вывода в данной грамматике цепочки a2b2a2 является вывод: Необходимо отметить, что хотя порождающая грамматика и описывает процесс порождения цепочек языка L(G), но описание это не является алго-ритмическим – в грамматике отсутствует одно из главных свойств алгоритма – детерминированность, т.е. не фиксируется конкретный порядок применения правил подстановки грамматики. За счет этого обеспечивается компактность описания языка. Зафиксировать такой перечисляющий алгоритм в общем слу-чае можно различными способами, но для точного определения языка этого не требуется. Таким образом, формальная грамматика G потенциально задает множество алгоритмов порождения языка, при этом мощность этого множе-ства алгоритмов совпадает с мощностью |L(G)|. Порождающая грамматика в том виде, как она была определена выше, является мощным описательным средством, но все же еще очень общего ха-рактера. Практическое применение грамматик связано с решением проблемы распознавания. Проблема распознавания разрешима, если существует такой алгоритм, который за конечное число шагов дает ответ на вопрос, принадле-жит ли произвольная цепочка над основным словарем грамматики языку, по-рождаемому этой грамматикой. Если такой алгоритм существует, то язык называется распознаваемым. Если к тому же число шагов алгоритм распозна-вания зависит от длины цепочки и может быть оценено до выполнения алго-ритма, язык называется легко распознаваемым [8]. В противном случае не име-ет смысла вести речь о построении транслятора для нераспознаваемого языка программирования. Поэтому на практике рассматриваются такие частные классы порождающих грамматик, которые соответствуют распознаваемым, а в большинстве случаев и легко распознаваемым языкам. Наиболее важные классы таких языков могут быть определены в рамках классификации языков, предложенной в 1959г. американским лингвистом Н.Хомским (классификация по Хомскому). Он предложил классифицировать формальные языки по типу правил порождающих их грамматик. Класс 0. Правила вывода грамматики имеют форму  без каких либо ограничений на строки  и . Языки этого класса могут служить моделью естественных языков. Класс 1. Все элементы Р получают из формы , где  = 12,  = 12;а 1, 2 V*, N, V+. Порождающая грамматика с такими правилами называется грамматикой непосредственно составляющих или контекстной грамматикой (КС-грамматика). Языки, порождаемые грамматиками этого класса, называют контекстно-зависимыми. В КС-грамматике каждое правило вывода указывает подстановку некоторой непустой цепочки  вместо нетер-минала  при условии, что заменяемый нетерминал  находится в окружении 1 и 2, т.е. строки 1 и 2 рассматриваются как контекст, в котором можно за-менить на . Языки класса 1 могут порождаться также грамматики, правая часть каждого правила которой не короче его левой части, т.е. длина цепочки при выводе в такой грамматике может только возрастать. Такая грамматика называется неукорачивающей. Класс КС-грамматик эквивалентен классу не-укорачивающих грамматик [8]. Грамматика из примера 1.3.2.2 является НС-грамматикой, у которой 12 =  . Класс 2. Все порождающие правила грамматики имеют вид А, где А – нетерминальный символ, а  – непустая цепочка из V, т.е. V+. Замена не-терминала А на строку  происходит без учета контекста, поэтому граммати-ки этого класса называют контекстно-свободными (КС-грамматиками). Если допустить, что V+, т.е. возможна пустая подстановка  вместо нетерминала А, то грамматика называется укорачивающей КС-грамматикой (УКС-грамматика). Доказано, что по любой УКС-грамматике можно построить по-чти эквивалентную КС-грамматику, т.е. порождающую тот же язык, что и ис-ходная грамматика , за исключением пустой цепочки. УКС-грамматики пред-ставляют практический интерес потому, что именно они используются для описания языков программирования. Почти эквивалентность УКС и КС-грамматик позволяет свести изучение УКС-грамматик к изучению соответ-ствующих свойств КС-грамматик. Поэтому КС-грамматики играют главную роль при формальном изучении синтаксиса языков программирования и по-строении блока синтаксического анализа транслятора. Класс 3. Все порождающие правила имеют вид: АbВ и Аb, где A,BN, bT, т.е. правая часть правила является или единичным терминалом, или единичным терминалом, за которым следует единичный нетерминал. Язы-ки класса 3 называют языками с конечным числом состояний или автоматны-ми (регулярными) языками, а порождающие их грамматики – автоматными грамматиками (А-грамматики). А-грамматики используются в основном на этапе лексического анализа. Связь между приведенными классами языков и проблемой распознава-ния языков формулируется следующей теоремой. Теорема 1.3.2.1. [8]. Язык L(G), порождаемый неукорачивающей грам-матикой G, легко распознаваем. Взаимосвязь (иерархия) языков в соответствии с классификацией Хом-ского определяется нижеследующей теоремой. Теорема 1.3.2.2. [4]. Если язык L(G) регулярный, то он контекстно-свободный. Если язык L(G) контекстно-свободный, то язык L(G)\ – НС-язык. Если язык L(G) – НС-язык, то он язык класса 0. С другой стороны, основные классы языков могут быть определены классами абстрактных распознающих устройств (автоматов), которые также образуют соответствующую иерархию. На рис.1.2 [7] приведена иерархия языков и соответствующие ей иерархии грамматик и автоматов как распозна-ющих устройств, основные из которых будут подробно описаны при рассмот-рении вопросов лексического и синтаксического анализа. Рис.1.2. Иерархия языков, грамматик и автоматов Из четырех классов грамматик контекстно-свободные грамматики наиболее важны в приложении к языкам программирования. С их помощью можно определить большую, хотя и не всю, часть синтаксической структуры языка программирования (ЯП). Ранее было показано, как для описания синтаксиса ЯП используются нормальные формы Бэкуса. Оказывается между БНФ и КС-грамматиками есть прямая связь – они, по существу, эквивалентны, различия касаются только обозначений. Так связке «::=» из БНФ соответствует в КС-грамматике отноше-ние , металингвистическим переменным из БНФ соответствуют в КС-грамматике нетерминальные символы, основным символам ЯП из БНФ соот-ветствуют терминальные символы КС-грамматики. В КС-грамматиках для со-кращения записи правила с одинаковыми левыми частями также собирают в одно, используя в качестве разделителя альтернатив знак | (или). 