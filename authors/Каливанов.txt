Лекция 2.5. Проектирование логической и физической схемы БД Лекция 2.5. Проектирование логической и физической схемы БД ........................ 1 Литература ........................................................................................................................1 2.5.1. Отображение концептуальной схемы на логическую модель данных ......... 1 2.5.2. Синтез оптимальной логической схемы БД ................................................ 3 2.5.3. Проектирование физической схемы БД .................................................... 10 2.5.4. Способы хранения отношений и их характеристики ................................. 11 2.5.5. Индексы ................................................................................................... 14 Литература 1. Атре Ш. Структурный подход к организации баз данных М: ФиС, 1983 г. 2. Кузнецов С.Д. Основы современных баз данных. Информационно-аналитические материалы Центра Информационных Технологий. Osbd.zip 2.5.1. Отображение концептуальной схемы на логическую модель данных Построенную концептуальную модель данных необходимо отобразить на логическую модель, поддерживаемую конкретной СУБД. При этом администратор БД должен решить какая модель данных (реляционная, иерархическая или сетевая) наиболее подходит для отображения концептуальной модели данных предметной области. Реляционная модель данных состоит из ряда отношений (таблиц, объектов). При отображении концептуальной модели на логическую необходимо определить отношения, их атрибуты и ассоциации (связи между объектами). Отношения, сформированные в результате, рассмотренной ранее нормализации, отражают пользовательские представления о логической модели базы данных. Отдельные атрибуты этих отношений являются их первичными ключами. Поэтому связи между объектами полностью определяются отношениями между атрибутами отношений. Таким образом, при реляционном подходе отображение концептуальной модели на логическую производится естественным образом в процессе нормализации. Преобразование концептуальной модели в логическую иерархическую или сетевую модель можно разбить на этапы и определить для каждого из них критерии выбора решения. Единственного, однозначного решения эта задача не имеет. При этом различают следующие основные этапы: I. Построение обобщенной логической модели, в которой не учитываются ограничения, накладываемые используемой СУБД. Лекции по СУБД. No 2.5. стр.1/17 Первый этап, как правило, предполагает проведение нормализации. II. Трансформирование построенной модели с учетом ограничений, накладываемых используемой СУБД. На втором этапе, как правило, учитывают следующие ограничения: – на количество типов сегментов (групповых полей и отношений); – на количество исходных и порожденных сегментов (владельцев и членов набора) и т.д.; III. Модифицирование трансформированной модели с учетом соображений, влияющих на производительность функционирования СУБД. Третий этап предполагает, что будет найден ответ на следующий вопрос: можно ли улучшить эксплуатационные характеристики будущей БД путем объединения сегментов и сокращения числа уровней, разбиения сегментов с целью более эффективной передачи данных или обеспечения их безопасности, объединения или разделения иерархий и других структурных изменений? На перечисленные вопросы можно ответить путем анализа ряда количественных характеристик, таких как частота использования различных путей в иерархии, среднее число экземпляров сегментов каждого типа, длины сегментов. Их рассмотрение относится в основном к физическому проектированию БД. Однако, и в процессе логического проектирования используют соображения, влияющие на производительность функционирования СУБД: IV. Формирование полного сцепленного ключа каждого порожденного сегмента. Четвертый этап предполагает, что полный сцепленный ключ порожденного сегмента формируется из ключей всех исходных сегментов, пройденных на пути от корневого сегмента к данному. V. Реализация взаимосвязей, не отображенных в логической модели. Пятый этап предполагает, что усовершенствованная логическая модель удовлетворяет функциональным требованиям и обеспечивает, очевидно, более высокую производительность, чем первоначальная концептуальная модель. На этом этапе можно было бы считать логическое проектирование, включающее отображение в иерархическую модель данных, завершенным. Однако, иногда требуется добавить ряд новых (скрытых) взаимосвязей, существующих между данными. Речь идет о реально существующих взаимосвязях, определяемых организационными или физическими характеристиками моделируемой предметной области, но явно не сформулированных в концептуальных требованиях. Основная причина реализации упомянутой взаимосвязи состоит в том, что БД должна обеспечивать получение ответов на произвольные запросы и легко адаптироваться для будущих применений. Лекции по СУБД. No 2.5. стр.2/17 2.5.2. Синтез оптимальной логической схемы БД Пусть дано описание предметной области «Системы связи» в виде информационных требований: Некоторые системы связи характеризуются своим названием НССВ R1 ( 1:1, 53, 12): (НССВ (10, 12) (ТТХСВ(43, 12, 1)), длина поля мощность мн-ва число значений Системы связи реализуются на каналах связи (нумерованных) с характеристиками: R2 ( M:1, 109, 120): (NКНЛСВ (12, 120) ( ТТХ КНЛСВ (24, 30, 4), ТипСВ (15, 8, 15), НОУ (48, 32, 3.8), НССВ (10, 12, 10)), Органы управления НССВ характеризуются наименованием (НОУ). Каждый НОУ может использовать несколько средств мобильности. Средства мобильности определяются номером (НСРМБ) и типом (TСРМБ). R3 ( 1:1, 82, 32): (НОУ (48, 32)( НЗНОУ (34, 32, 1)), R4 ( M:1, 58, 240): (NСРМБ (2, 240) (TСРМБ(8, 10, 24), НОУ(48, 32, 7.5)) Диаграмма Бахмана предметной области «Системы связи»: НОУ НССВ ЯРУС 1 NСРМБ У НОУ НЗНОУ НССВ ТТХ ССВ NКНЛСВ NСРМБ ТСРМБ NКНЛСВ ТТХ КНЛСВ Т СВ ЯРУС 2 На основе информационных требований строится Матрица канонической структуры: Третьи числа  Wn= 1 0 C(aI ) RL(aJ ,aI )   (по обратной связи в иерархии) Вторые числа  (a ,a ) IJ   Лекции по СУБД. No 2.5. стр.3/17  где  1 НОУ 2 НССВ 3 NСРМБ 4 NКНЛСВ Производится анализ запросов: Тогда W4 = 32 0 7.5 3.8 0 12 0 10 1 0 240 0 1 1 0 120 ЯРУС 1 ЯРУС1 ЯРУС 2 ЯРУС 2 c(ai ) − мощность множества атрибутов аi RL(aj , ai )−третьи числа в описаниииони ij =проставляютсякогда(аj,аi)F 1, (ai , a j ) − образуют отношение 0, (ai , aj )− не образуют Запрос No1 с частотой 3 – TR1(3). Изменить все характеристики КС определенного типа в зависимости от типа связи и выдать наименования органов управления, где эти характеристики изменились. TR1(3): DO a = ENTRY( НССВ ) WHILE ( НССВ0,08 ); DO b = NКНЛСВ( а ) WHILE ( ТСВ 0,3 ); UPDATE ( ТТХКНЛСВ( b ) ); DO c = НОУ( b ); FETCH( c ); END DO; END DO; END DO; Запрос No2. Изменить, либо исключить технические средства базирования заданного типа. TR2(6): DO a = ENTRY( NСРМБ ); IF ТСРМБ( а ) THEN( 0,6 ) UPDATE(ТСРМБ( а ) ); ELSE ТСРМБ( а ) THEN( 0,2 ) DELETE( a ); END IF; END DO; Запрос No3. Выдать номер КС и соответствующее наименование системы связи, если ТТХКНЛСВ хуже заданных. Лекции по СУБД. No 2.5. стр.4/17 TR3(10): DO a = ENTRY ( НССВ ); DO b = NКНЛСВ WHILE( ТТХКНЛСВ 0,1 ); FETCH( a, b ); END DO; END DO; В ходе анализа выявляются группы зависимых и независимых требований. Независимыми называются требования, не влияющие на реализацию в структуре БД остальных групп требований. Независимые требования возникают в транзакциях, которые реализуют параллельные пути селекции (чаще всего, когда возможны несколько точек входа в транзакцию). Будем обозначать логическую схему точкой входа S. Такое обозначение не противоречит принятым обозначениям: S<A,F> – схема, система, предметная область; S – точка входа, корень дерева, иерархии. Выбор схемы S зависит от расходуемых ресурсов (см. далее). Так, для TR3: 1. 2. 3. S → НССВ по НССВ – независимы: НССВ → NКНЛСВ по ТТХКНЛСВ – зависимы; NКНЛСВ → НССВ по ТТХКНЛСВ – зависимы. Обработанные запросы анализируются и выявляются требования к структуре БД: 1 требование: на точку входа (т.е. необходимо определить имя первого квалифицированного сегмента): ENTRY; 2 требование: на упорядоченность связи между сегментами ( DO, WHILE, IF ); 3 требование: на дополнительную связь и дополнительный путь селекции (т.е. выявляется необходимость выполнения операций соединения). Для выбора оптимальной схемы необходимо найти минимум следующей функции minxi GiOpt{S(Gi)}. xi 0 где Gi − общие затраты на реализацию варианта Si схемы БД; G0 − предполагаемые общие затраты на реализацию варианта схемы БД (возможно, уже существующей, находящейся в эксплуатации); G = Gi – G0 . Поясняем xi : так как любая структура может быть представлена в виде некоторого дерева, то путем выбора той или иной ветви i мы выделяем подгруппы вариантов Si : j Si j =2  xi = | Si | = 7 Лекции по СУБД. No 2.5. стр.5/17 Величина xi принимает значение либо 0, либо 1 x = 1 , если существует i вариант. систему неравенств:  min {V }  0 i{S ,...,S ..,S } 1im i 0 , если не существует Обычно рассматривают две основные группы ресурсов, которые будут расходоваться при эксплуатации БД, созданной по тому или иному варианту схемы для заданной предметной области. В первую группу входят ресурсы внешней памяти на носителе информации, а во вторую – затраты времени на выполнение информационных запросов TRq [ q = 1, Q ] и затраты на путь селекции данных при их выполнении. В общем случае для выбора оптимальной схемы необходимо решить следующую i{S1,...,Si ..,Sm } i  m i n { T i }  0 (4.5.1) , где V i = VSi – ресурсы из первой группы – внешняя память; T i = T Si – ресурсы из второй группы – затраты времени. В результате решения системы (4.5.1) стремятся найти (если удастся) аргумент i{S1,...,Si..,Sm}соответствующий оптимальной по затратам ресурсов схеме БД. Таким образом, в общем виде, требуется решить следующую задачу:  min {V }  0 a r g  i  { S 1 , . . . , S i . . , S m } i  S(opt) = { S , S , . . . S }  m i n { T i }  0  12 m i{S,...,S..,S} 1im  Затраты ресурсов из первой группы V i зависят от длин полей vl [ l = 1, N ] отведенных для хранения отношений, а также от состава дополнительных индексов I{l} и другой служебной информации, характеризующей схему. Поэтому для расчёта затрат внешней памяти необходимо использовать информационные требования к БД, рассмотренные выше. Затраты ресурсов из второй группы зависят от точки входа Pl (отдельного атрибута, или отношения в целом) в схему БД. При этом также необходимо использовать информационные требования к БД. Таким образом, решение задачи должно удовлетворять следующим ограничениям: Ti →0 , Ti =T0 −Ti и Ti →T0, xi  0 где Ti = TSi − затраты времени на реализацию варианта схемы БД. Лекции по СУБД. No 2.5. стр.6/17 a. Sa → T0 = TS0 − предполагаемые затраты времени на реализацию оптимальной схемы БД. Ограничения по объему памяти (разности объемов) состоят в следующем:   V i → 0 ,  V i = V 0 − V i и V i → V 0 , xi  0 где Vi = VSi − затраты внешней памяти на реализацию варианта схемы БД. V0 = VS0 − предполагаемые затраты внешней памяти на реализацию оптимальной схемы БД. Рассмотрим порядок их расчета на примере двух схем. НССВ NСРМБ ТСРМБ НОУ НЗНОУ b. Sb→ NСРМБ ТСРМБ Определяем требования на точку входа: в 1-м запросе НССВ 2-м запросе NКНЛСВ 3-м запросе НССВ СВ ТТХНССВ NКНЛСВ ТТХКНЛСВ НОУ НЗНОУ NКНЛСВ ТТХКНЛ ТСВ НССВ ТТХНССВ Лекции по СУБД. No 2.5. стр.7/17 ТСВ Могут быть и другие точки входа: 1 NСРМБ 2 НОУ Общие затраты времени на реализацию варианта схемы БД: Т =tnn+td d , где td - время прохождения между двумя ближайшими сегментами; затраты на выборку очередного сегмента (переход к другому реляционному отношению); tn - затраты времени на обработку единицы информации; d - путь от одного сегмента к другому – длина пути; n- затраты на точку входа. Затраты на путь селекции: D – матрица путей: НССВ НОУ Da = NКНЛСВ NСРМБ Путь вычисляется следующим образом: Вводится метрика: d(ai , ai ) = 0 d(ai , a j ) = d(ai , ak ) + d(ak , aj ) d(ai,ak)=1, k=i+1 Множество возможных точек входа определяется, следующим образом: где S (фиктивный сегмент). Затраты на точку входа Затраты на текущем шаге равны затратам на предыдущем шаге плюс затраты на предыдущем шаге умноженные на значение элемента матрицы канонической структуры: или 1234 1234 НССВ 0 2 1 3 НОУ 2 0 1 1 Db=NКНЛСВ 1 1 0 2 NСРМБ 3 1 2 0 S1324 S3122 0 2 2 0 11 3 1 1 3 1 1 0 2 2 0 E N = a d ( S , a ) = 1  nl =nl−1 +nl−1(ai ,aj ) nl =nl−1 +nl−1  k=1  (a ,a ) kij где k – число взаимно-независимых сегментов, которые требуется выбрать по запросу на уровне (шаге) l Лекции по СУБД. No 2.5. стр.8/17 k При этом n0 =(al ,al ), где al - точка входа (для TR1 и TR3 n0=ω(НССВ, НССВ)). Для схемы а для TR1: Вычисление затрат на точку входа: S → НССВ НССВ → NКНЛСВ NКНЛСВ → НОУ [ТСВ, ТТХКНЛСВ] Затраты на путь: d( НССВ, НОУ ) = 2 Общие затраты времени: n0 =  ( НССВ, НССВ ) = 12 n1 = n0 + n0 ( НССВ, NКНЛСВ ) = 12 + 1210 = 132 n2 = n1 + n1 (NКНЛСВ, НОУ ) = 132 + 1321 = 264 Т=tn 264+td 2 Затраты внешней памяти: Va= k  = (12  53 + 120 109 + 32  82 + 240  58) = 30260 длина, мощность 4 Nr r   v Va= k v r,l   r,l   r=1 |R| l=1 Nr   r=1 r  l=1 где kr – мощность множества кортежей vr,l – длина кортежа r – номер отношения Для схемы b для TR1: Вычисление затрат на точку входа: S → НОУ НОУ → NКНЛСВ NКНЛСВ → НССВ Транзакция TR1.б(3): n0 = ( НОУ, НОУ ) = 32 n1 = n0 +n0( НОУ, NКНЛСВ ) = 32 + 323,8 = 153,6 n2 = n1 +n1( NКНЛСВ, НССВ ) = 153,6 +153,61 = 307,2 DO c=ENTRY(НОУ); DO b = NКНЛСВ( c ) WHILE ( ТСВ  0,3 ); UPDATE ( ТТХКНЛ( b ) ); IF НССВ ( b ) THEN( 0,08 ) FETCH ( c ); END IF; END DO; END DO; Затраты на путь: d( НОУ, НССВ ) = 2 Лекции по СУБД. No 2.5. стр.9/17 Общие затраты времени: Т=tn 307,2+td 2 Вывод : схема Sa оптимальна для транзакции TR1. 2.5.3. Проектирование физической схемы БД Проектирование физической схемы БД заключается в дополнении ее логической схемы такими характеристиками, которые необходимы, во–первых, для определения способов физического хранения и использования БД и во–вторых, для определения объемов памяти, требуемой для всей системы и для оценки производительности обработки. В результате проектирования логической схемы БД, проектировщик, как правило, получает несколько вариантов схемы. Поэтому в процессе физического проектирования ему требуется произвести сравнение этих вариантов. Для того, чтобы БД обеспечивала требуемые значения оценок производительности, необходимо хорошо знать методы доступа как внутренней модели (физической), так и внешней (представления пользователя). На практике, увеличение числа операций физического ввода–вывода, выполняемых при обработке данных для удовлетворения запроса пользователя, приводит к снижению производительности. При проектировании БД необходимо иметь ввиду, что производительность системы в значительной степени зависит от методов доступа внутренней модели БД. Она определяется двумя характеристиками: 1. качество доступа – определяется величиной, обратной среднему числу физических обращений: 1(К−воОпераций), – необходимых для осуществления логического доступа, т.е. выборки конкретной записи базы данных. Физические обращения обеспечивают удовлетворение запроса. Например, если для поиска требуемой записи система обращается к двум записям, то значение характеристики доступа равно 0,5. 2. качество хранения – определяется величиной, обратной среднему числу байтов поля вторичной памяти (при индексировании БД): Vисх Vиндекс , требуемого для хранения одного байта исходных данных. Кроме исходных данных память занимает управляющая информация (служебная БД); область, не используемая из– за фрагментации и т.д. Лекции по СУБД. No 2.5. стр.10/17 Существует взаимообратная зависимость между затратами памяти и времени, т.е. введением избыточности данных можно исключить ряд физических операций ввода- вывода, а отсутствие избыточности сохраняет память, но увеличивает временные затраты. Однако, не следует увлекаться оптимизацией затрат памяти и времени и забывать о практических требованиях. Вероятно, с точки зрения практического использования БД необходимо иметь множество точек входа в нее, или обращаться к конкретному типу записи по более чем одному ключу. Однако, это может повлечь за собой инвертирование файла относительно этих ключей, и скорее всего приведет к росту накладных расходов памяти и времени. Рост накладных расходов – вот, что является платой за удовлетворение конкретного требования практики. 2.5.4. Способы хранения отношений и их характеристики Существуют два принципиальных подхода к физическому хранению отношений. Наиболее распространенным является покортежное хранение отношений (кортеж является единицей физического хранения). Естественно, это обеспечивает быстрый доступ к целому кортежу, но при этом во внешней памяти дублируются общие значения разных кортежей одного отношения и, вообще говоря, могут потребоваться лишние обмены с внешней памятью, если нужна часть кортежа. Менее распространенным подходом является хранение отношения по столбцам, т.е. единицей хранения является столбец отношения с исключенными дубликатами значений (домен). Естественно, что при такой организации суммарно в среднем тратится меньше внешней памяти, поскольку дубликаты значений не хранятся; за один обмен с внешней памятью в общем случае считывается больше полезной информации. Дополнительным преимуществом является возможность использования значений столбца отношения для оптимизации выполнения операций соединения. Но при этом требуются существенные дополнительные действия для сборки целого кортежа (или его части). Характеристики последовательного поиска данных Будем предполагать, что нам задан поисковый признак (ключ)  и критерий поиска  < . Метод последовательного просмотра – универсальный метод (позволяет работать как с упорядоченным, так и с неупорядоченным файлом). Упорядоченным будем называть файл, записи которого упорядочены по значению некоторого ключа. Лекции по СУБД. No 2.5. стр.11/17 Тогда, для поиска всех записей, удовлетворяющих критерию поиска  <  будет просмотрено в среднем следующее число записей: Cсреднее = n - при неупорядоченном, Cсреднее = n + 1 , для n нечетного (при упорядоченном массиве), 2 где n – общее число записей в файле. Метод блочного поиска. Если записи упорядочены по некоторому ключу, то при поиске не обязательно просматривать каждую запись. Можно просматривать интервалы из m записей в последовательности возрастания ключей. При нахождении записи с ключом  >  просматриваются не более, чем m − 1 последних записей, которые были пропущены в последнем интервале. Величина блока, обеспечивающая минимальное число просматриваемых записей составляет следующим образом: Пусть N F - число записей в файле , N B - число записей в блоке. n = m = N B = N F . Это можно показать Тогда, необходимо сформировать N F N B  блоков (  - знак целого числа). Среднее число блоков, которое надо просмотреть, чтобы найти искомый блок, равно: NF NB СЧБ = kP , где P - вероятность того, что kй блок содержит искомую kk k=1 запись. Если вероятность распределена равномерно, то СЧБ равно: NF NB NF NB+1 СЧБ= k1NF NB= 2 , k=1 если N F N B  нечетное. Когда блок найден, то первая (или последняя) запись уже проанализирована, и тогда среднее число записей, просмотренных в блоке (СЧЗБ): N−1 СЧЗБ = B i  p , где p – вероятность того, что i-я запись искомая. ii i=1 Если вероятность распределена равномерно, то СЧЗБ = Лекции по СУБД. No 2.5. стр.12/17 i=1 NB 2 N−1 1 N−1 B i  = B , Пусть N – общее число записей, просматриваемых при поиске. Тогда СЧЗ ( E(N) ), )=CЧБ+СЧЗБ= 1 NF + NB . (1) 2 NB 2 dE(N ) − NF + 1 = 0, dN 2N2 2 Число записей, которые должны быть просмотрены, если в каждом блоке содержатся N B = N F записей равно (из (1)). которые должны быть просмотрены: E(N NB , при котором E(N )→min :  т.е.NF =1,итогдаNB=NF. 2NB2 2 E(N )=1 NF +NF N . pF BB 2N 2 F И окончательно Cсреднее = n . Метод дихотомического поиска – необходимо, чтобы файл с известным числом записей был упорядочен. В этом методе значение поискового признака  сравнивается с величиной * = 1⁄2 (max {}): Если  < * , то поиск осуществляется в первой половине файла, если  >= * , то во второй. Сср =( log2 n ) +1- самый быстрый метод. <> ... ... ... ... Рисунок 2.5.4.1 – Схема дихотомического поиска. a b c ... 1 Лекции по СУБД. No 2.5. стр.13/17 ...n Достоинства методов (всех методов, рассмотренных до дихотомического) − простота реализации; Недостатки: − трудоемкость; Достоинства дихотомического метода − скорость Недостатки (дихотомии): − необходимость разметки набора (подсчет числа записей и упорядочивание). Обычно реализуется комбинация. Пример: при использовании индексов – блочный поиск, а внутри блока – последовательный. 2.5.5. Индексы Для улучшения характеристик поиска часто используют такие средства для связывания значений данных с адресом их хранения, как индексы. Определение. Индексом называется пара <ЗначениеКлючевогоАтрибута, АдресДанных>. Индекс, содержащий пару:<ЗнКлАтр, АдрД>, на каждое значение данных, называют плотным. Если индексируются не все значения данных, то индекс – разреженный. Главный индекс – это один из возможных ключей, как правило, являющийся первичным (сингулярным и уникальным) ключом. Дополнительный индекс – это индекс, построенный по значениям поля, не являющегося первичным ключом записи. Файл, имеющий дополнительные индексы на все поля записи, называется инвертированным файлом. Если же не все поля записи проиндексированы, то файл называется частично инвертированным. Как бы ни были организованы индексы в конкретной СУБД, их основное назначение состоит в обеспечении эффективного прямого доступа к кортежу отношения по ключу. Обычно индекс определяется для одного отношения, и ключом является значение атрибута (возможно, составного). Если индексом является возможный ключ отношения, то индекс должен обладать свойством уникальности. На практике же зачастую происходит наоборот: при объявлении первичного ключа отношения автоматически создается уникальный индекс, а единственным способом объявления возможного ключа, отличного от первичного, является явное создание уникального индекса. Поскольку при выполнении многих операций языкового уровня требуется сортировка отношений в соответствии со значениями некоторых атрибутов, то полезным свойством Лекции по СУБД. No 2.5. стр.14/17 индекса является обеспечение последовательного просмотра кортежей отношения в диапазоне значений ключа в порядке возрастания или убывания значений ключа. Наконец, одним из способов оптимизации выполнения эквисоединения отношений (наиболее распространенная из числа дорогостоящих операций) является организация так называемых мультииндексов для нескольких отношений, обладающих общими атрибутами. Любой из этих атрибутов (или их набор) может выступать в качестве мультииндекса. Значению ключа сопоставляется набор кортежей всех отношений, связанных мультииндексом, в которых значения выделенных атрибутов совпадают со значением ключа. Общей идеей любой организации индекса, поддерживающего прямой доступ по ключу и последовательный просмотр в порядке возрастания или убывания значений ключа является хранение упорядоченного списка значений ключа с привязкой к каждому значению ключа списка идентификаторов кортежей. Одна организация индекса отличается от другой главным образом способом поиска ключа с заданным значением. 2.5.5.1. B-деревья Видимо, наиболее популярным подходом к организации индексов в базах данных является использование техники B-деревьев. При этом необходимо понимать, что совокупность отношений реляционной БД можно представить в виде дерева отношений (иерархии, графа). С точки зрения внешнего логического представления B-дерево – это сбалансированное сильно ветвистое дерево, размещенное во внешней памяти. Сбалансированность означает, что длина пути от корня дерева к любому его листу одна и та же. Ветвистость дерева – это свойство каждого узла дерева ссылаться на большое число узлов-потомков. С точки зрения физической организации B-дерево представляется как мультисписочная структура страниц внешней памяти, т.е. каждому узлу дерева соответствует блок внешней памяти (страница). Поиск в B-дереве – это прохождение от корня к листу в соответствии с заданным значением ключа. Для сильно ветвистых и сбалансированных деревьев, при выполнении поиска по любому значению ключа потребуется одно и то же (и обычно небольшое) число обменов с внешней памятью. Если более точно, то в сбалансированном дереве, где длины всех путей от корня к листу одни и те же, если во внутренней странице помещается m значений ключей (следовательно, из вершины должно исходить m дуг), то при хранении n записей потребуется дерево глубиной logm(n), (logm – логарифм по основанию m). Если m достаточно велико, то глубина дерева невелика, и производится быстрый поиск. Лекции по СУБД. No 2.5. стр.15/17 ... ... ... Множество значений ключа хэш F (x) Адресное пространство хранения индекса Область переполнения интервал m1 интервал mk ... ... a << < интервал m... ... b c 1 внутренняя страница (m ближайших значений ключа) Рисунок 2.5.5.1 – Сбалансированное ветвистое В-дерево. Основной "изюминкой" B-деревьев является автоматическое поддержание свойства сбалансированности. 2.5.5.2. Хеширование Более популярным подходом к организации индексов является использование техники хеширования. Общей идеей методов хеширования является применение к значению ключа некоторой функции свертки (хеш-функции), вырабатывающей значение адреса для размещения записи (кортежа). В самом простом, классическом случае, свертка ключа используется как адрес в таблице, содержащей ключи и записи. Основным требованием к хеш-функции является обеспечение равномерного распределения отношений, кортежей, записей. При возникновении коллизий (вычислено одно и то же значение свертки для нескольких значений ключа) образуются цепочки переполнения. ... ...n a b с ... z ... Рисунок 2.5.5.2 – Схема хранения индекса с использованием хеш-функции. Главным ограничением этого метода является фиксированный размер таблицы. Если таблица заполнена слишком сильно или переполнена, то возникнет слишком много цепочек Лекции по СУБД. No 2.5. стр.16/17 переполнения, и главное преимущество хеширования – доступ к записи за одно обращение к таблице – будет утрачено. Для расширения таблицы требуется ее полная реорганизация (создание) на основе новой хеш-функции. Для баз данных такие действия являются абсолютно неприемлемыми. Поэтому обычно вводят промежуточные таблицы-справочники, содержащие значения ключей и адреса записей, а сами записи хранятся отдельно. Тогда при переполнении справочника требуется реорганизация только справочника, что влечет меньше накладных расходов. Чтобы избежать потребности в полной переделке справочников, при их организации часто используют технику B-деревьев с расщеплениями и слияниями. Хеш-функция при этом меняется динамически, в зависимости от глубины B-дерева. Путем дополнительных технических ухищрений удается добиться сохранения порядка записей в соответствии со значениями ключа. В целом методы B-деревьев и хеширования все более сближаются. Лекции по СУБД. No 2.5. стр.17/17 